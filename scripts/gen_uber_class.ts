import * as ts from 'typescript';
const fs = require('fs');
// TODO: maintainer - if a new client is added, add it to this list

// Intentionally not surfacing projectServiceClient - it has methods that do not follow these patterns
const clients = [
  'DatasetServiceClient',
  'TableServiceClient',
  'JobServiceClient',
  'ModelServiceClient',
  'RoutineServiceClient',
  'RowAccessPolicyServiceClient',
];
const files = [
  '../src/v2/dataset_service_client.ts',
  '../src/v2/table_service_client.ts',
  '../src/v2/job_service_client.ts',
  '../src/v2/model_service_client.ts',
  '../src/v2/routine_service_client.ts',
  '../src/v2/row_access_policy_service_client.ts',
];
const output = `
// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// ** This file is automatically generated by gapic-generator-typescript. **
// ** https://github.com/googleapis/gapic-generator-typescript **
// ** All changes to this file may be overwritten. **

`;
let foundNodes = [];
function extract(node: ts.Node, depth = 0, client): void {
  // Create a Program to represent the project, then pull out the
  // source file to parse its AST.

  function getKind(node: ts.Node) {
    return ts.SyntaxKind[node.kind];
  }
  const thingsWeCareAbout = ['MethodDeclaration'];
  const kind = getKind(node);
  if (thingsWeCareAbout.includes(kind)) {
    if (ts.isMethodDeclaration(node)) {
      // this typecasting has to be done because the name of a MethodDeclaration
      // can be one of a few different types but in our use case we know it's an identifier
      // and can therefore safely make this assumption to get the human readable name
      const name = node.name as ts.Identifier;
      const nameEscapedText = name.escapedText as string;
      // full implementation (not overload) of crud method for client
      // this does not include "undelete" because "delete" will capture it
      const adminMethodPrefixes: string[] = [
        'get',
        'list',
        'delete',
        'patch',
        'update',
        'insert',
        'cancel',
      ];
      adminMethodPrefixes.forEach((method: string) => {
        // type is the node.type and we can deal with union types later
        if (node.body && nameEscapedText.search(method) >= 0) {
          // type is the node.type and we can deal with union types later
          foundNodes.push([node.name, node]);
        }
      });
    }
  }
  // Loop through the root AST nodes of the file
  ts.forEachChild(node, childNode => {
    extract(childNode, depth + 1, client);
  });
}

function ast(file, client) {
  let output = '';
  const program = ts.createProgram([file], {allowJs: true});
  const sourceFile = program.getSourceFile(file);

  // Run the extract function with the script's arguments
  extract(sourceFile!, undefined, client);
  // Either print the found nodes, or offer a list of what identifiers were found
  const checker = program.getTypeChecker();

  foundNodes.map(f => {
    const [name, node] = f;
    // create function name
    const functionName = `${name.escapedText}`;
    if (
      functionName.search('Stream') < 0 &&
      functionName.search('Async') < 0 &&
      functionName.search('ProjectId') < 0 &&
      functionName.search('getQueryResults') < 0
    ) {
      output = output.concat(`\n\t${functionName}(`);
      // add parameters
      let parametersList = '';
      let argumentsList = '';
      for (let i = 0; i < node.parameters.length; i++) {
        const name = node.parameters[i].name.escapedText;
        const questionToken = node.parameters[i].questionToken ? '?' : '';
        const typeString = node.parameters[i].type.getFullText();
        let parameter = `${name}${questionToken}: ${typeString}`;

        parametersList = parametersList.concat(name);
        // this has to do with function overloading - we will later surface code
        // that does type checking for options and callback
        if (name === 'optionsOrCallback') {
          argumentsList = argumentsList.concat('options');
        } else {
          argumentsList = argumentsList.concat(name);
        }
        if (i !== node.parameters.length - 1) {
          parameter += ', ';
          parametersList += ', ';
          argumentsList += ', ';
        }
        output = output.concat(`\n\t\t${parameter}`);
      }
      output = output.concat(')');
      // add return type

      const returnType = node.type!.getFullText();
      output = output.concat(`:${returnType}`);
      // call underlying client function
      if (node.body) {
        // this logic needs to be surfaced from underlying clients
        // to make sure our parameters play nicely with underlying overloads
        // otherwise you will run into issues similar to https://github.com/microsoft/TypeScript/issues/1805
        // we also add a check for undefined callback 
        const optionsOrCallback = `
            request = request || {};
            let options: CallOptions;
            if (typeof optionsOrCallback === 'function' && callback === undefined) {
                callback = optionsOrCallback;
                options = {};
            }
            else {
                options = optionsOrCallback as CallOptions;
            }
            if (callback === undefined){
              return this.${client.toLowerCase()}Client.${functionName}(request, options)

            }
            return this.${client.toLowerCase()}Client.${functionName}(${argumentsList})\n    
            `;
        output = output.concat(
          `{\n${optionsOrCallback}}`
        );
      }
    }
  });

  return output;
}

function astHelper(files, clients) {
  let output = '';
  for (const f in files) {
    foundNodes = [];
    const client = clients[f].split('Service')[0];
    output = output.concat(ast(files[f], client));
  }
  return output;
}

// TODO - make dynamic
function makeImports(clients) {
  let imports = 'import {protos';
  for (const client in clients) {
    imports = imports.concat(`, ${clients[client]}`);
  }

  imports = imports.concat('} from ".";\n');
  imports = imports.concat('import type * as gax from "google-gax";\n');

  imports = imports.concat(
    'import {Callback, CallOptions, ClientOptions, PaginationCallback} from "google-gax";\n'
  );
  return imports;
}

// convert client types to the names we'll use for variables
function parseClientName(client) {
  return client.split('ServiceClient')[0].toLowerCase() + 'Client';
}
function buildOptionTypes(clients) {
  let output = '';
  const docstring = `/**
   * Options passed to the underlying client.
   *
   * @param {object} [options] - The configuration object.
   * The options accepted by the constructor are described in detail
   * in [this document](https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#creating-the-client-instance).
   * The common options are:
   * @param {object} [options.credentials] - Credentials object.
   * @param {string} [options.credentials.client_email]
   * @param {string} [options.credentials.private_key]
   * @param {string} [options.email] - Account email address. Required when
   *     using a .pem or .p12 keyFilename.
   * @param {string} [options.keyFilename] - Full path to the a .json, .pem, or
   *     .p12 key downloaded from the Google Developers Console. If you provide
   *     a path to a JSON file, the projectId option below is not necessary.
   *     NOTE: .pem and .p12 require you to specify options.email as well.
   * @param {number} [options.port] - The port on which to connect to
   *     the remote host.
   * @param {string} [options.projectId] - The project ID from the Google
   *     Developer's Console, e.g. 'grape-spaceship-123'. We will also check
   *     the environment variable GCLOUD_PROJECT for your project ID. If your
   *     app is running in an environment which supports
   *     {@link https://developers.google.com/identity/protocols/application-default-credentials Application Default Credentials},
   *     your project ID will be detected automatically.
   * @param {string} [options.apiEndpoint] - The domain name of the
   *     API remote host.
   * @param {gax.ClientConfig} [options.clientConfig] - Client configuration override.
   *     Follows the structure of {@link gapicConfig}.
   * @param {boolean} [options.fallback] - Use HTTP/1.1 REST mode.
   *     For more information, please check the
   *     {@link https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#http11-rest-api-mode documentation}.
   * @param {gax} [gaxInstance]: loaded instance of \`google-gax\`. Useful if you
   *     need to avoid loading the default gRPC version and want to use the fallback
   *     HTTP implementation. Load only fallback version and pass it to the constructor:
   *     \`\`\`
   *     const gax = require('google-gax/build/src/fallback'); // avoids loading google-gax with gRPC
   *     const client = new DatasetServiceClient({fallback: true}, gax);
   *     \`\`\`
   */\n`;
  const subClientOptionsType = `export type subClientOptions = {opts?: ClientOptions,
    gaxInstance?: typeof gax | typeof gax.fallback};\n\n`;
  output = output.concat(docstring, subClientOptionsType);
  let bigQueryOptionsType = 'export type bigQueryClientOptions = {\n';
  for (const client in clients) {
    let variableDecl = '';
    const clientName = parseClientName(clients[client]);
    variableDecl = variableDecl.concat(
      `\t${clientName}?: ${clients[client]};\n`
    );
    bigQueryOptionsType = bigQueryOptionsType.concat(variableDecl);
  }
  bigQueryOptionsType = bigQueryOptionsType.concat('};\n\n');
  output = output.concat(bigQueryOptionsType);
  return output;
}
// TODO modify to be able to pass option to subclients
function buildClientConstructor(clients) {
  let variableDecl = '';
  const comment = `\t/**
  * @param {object} [bigQueryClientOptions] - Enables user to instantiate clients separately and use those as the subclients.
  * @param {object} [subClientOptions] - These options will be shared across subclients. 
  * To have sub-clients with different options, instantiate each client separately.
  */`;
  let constructorInitializers =
    '\tconstructor(options?: bigQueryClientOptions, subClientOptions?: subClientOptions){\n';
  for (const client in clients) {
    const clientName = parseClientName(clients[client]);
    variableDecl = variableDecl.concat(
      `\t${clientName}: ${clients[client]};\n`
    );
    constructorInitializers = constructorInitializers.concat(
      `\t\tthis.${clientName} = options?.${clientName} ?? new ${clients[client]}(subClientOptions?.opts, subClientOptions?.gaxInstance);\n`
    );
  }
  constructorInitializers = constructorInitializers.concat('\t}');
  let output = 'export class BigQueryClient{\n';
  output = output.concat(
    variableDecl,
    '\n',
    comment,
    '\n',
    constructorInitializers
  );
  return output;
}

function buildOutput() {
  let newoutput;
  newoutput = output.concat(makeImports(clients));
  newoutput = newoutput.concat(buildOptionTypes(clients));
  newoutput = newoutput.concat(buildClientConstructor(clients));
  newoutput = newoutput.concat(astHelper(files, clients));
  newoutput = newoutput.concat('\n}');
  return newoutput;
}

const finaloutput = buildOutput();
fs.writeFile('../src/bigquery.ts', finaloutput, err => {
  if (err) throw err;
});
