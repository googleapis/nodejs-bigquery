// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import * as ts from 'typescript';
import * as fs from 'fs';
import * as prettier from 'prettier';

// TODO(maintainer) - if a new client is added, add it to this list

// Intentionally not surfacing projectServiceClient - it has methods that do not follow these patterns
const CLIENTS = [
  'DatasetServiceClient',
  'TableServiceClient',
  'JobServiceClient',
  'ModelServiceClient',
  'RoutineServiceClient',
  'RowAccessPolicyServiceClient',
];
const FILES = [
  '../src/v2/dataset_service_client.ts',
  '../src/v2/table_service_client.ts',
  '../src/v2/job_service_client.ts',
  '../src/v2/model_service_client.ts',
  '../src/v2/routine_service_client.ts',
  '../src/v2/row_access_policy_service_client.ts',
];
const LICENSE = `
// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// ** This file is automatically generated **
// ** All changes to this file may be overwritten. **

`;

const EXCLUDED_FUNCTION_TERMS = [
  'getQueryResults', // only surfacing admin plane methods for now
  'ProjectId', // don't surface getProjectId methods - there will be conflicts
];
type NameMethodPair = [ts.PropertyName, ts.MethodDeclaration];
type MethodDocstringMap = Map<string, string>;
let foundNodes: NameMethodPair[] = [];
const methodDocstrings: MethodDocstringMap = new Map();
let sourceFile: ts.SourceFile;

function getEscapedText(name: ts.PropertyName | ts.BindingName): string {
  // this typecasting has to be done because the name of a MethodDeclaration a parameter
  // can be one of a few different types but in our use case we know it's an identifier
  // and can therefore safely make this assumption to get the human readable name
  name = name as ts.Identifier;
  const nameEscapedText = name.escapedText as string;
  return nameEscapedText;
}
function extract(node: ts.Node, depth = 0, client: string): void {
  function getKind(node: ts.Node) {
    return ts.SyntaxKind[node.kind];
  }
  const methodsToInclude = ['MethodDeclaration'];
  const kind = getKind(node);
  if (methodsToInclude.includes(kind)) {
    if (ts.isMethodDeclaration(node)) {
      const nameEscapedText = getEscapedText(node.name);
      const adminMethodPrefixes: string[] = [
        'get',
        'list',
        'delete',
        'patch',
        'update',
        'insert',
        'cancel',
        'undelete',
      ];
      adminMethodPrefixes.forEach((method: string) => {
        // the typescript compiler API does not recognize docstrings as a type of node
        // so they have to be extracted from the full file text.
        // If a method has overloads, the docstring will be part of the first overload
        // we construct this map so that we can retrieve the proper docstring later
        if (methodDocstrings.get(nameEscapedText) === undefined) {
          // gets the text range in the file where the comment for this method is
          const commentRanges = ts.getLeadingCommentRanges(
            sourceFile.getFullText(),
            node.getFullStart(),
          );
          let docString = '';
          // concatenates all parts of the comment into a string
          if (commentRanges) {
            commentRanges.map(r => {
              docString = docString.concat(
                sourceFile!.getFullText().slice(r.pos, r.end),
              );
              if (r.hasTrailingNewLine) {
                docString = docString.concat('\n');
              }
            });
          }
          // store for later
          methodDocstrings.set(nameEscapedText, docString);
        }

        // full implementation (not overload) of crud method for client
        if (node.body && nameEscapedText.startsWith(method) === true) {
          foundNodes.push([node.name, node]);
        }
      });
    }
  }
  // Loop through the root AST nodes of the file
  ts.forEachChild(node, childNode => {
    extract(childNode, depth + 1, client);
  });
}

// contains the logic to traverse each file and pull in the nodes from the AST
// that contain elements we want to use
function ast(file: string, client: string) {
  let output = '';
  const program = ts.createProgram([file], {allowJs: true});
  sourceFile = program.getSourceFile(file)!;

  // Run the extract function with the script's arguments
  extract(sourceFile, undefined, client);
  program.getTypeChecker();

  foundNodes.map(f => {
    const [name, node] = f;
    const escapedName = getEscapedText(name);

    // create function name
    const functionName = `${escapedName}`;
    let isExcludedFunction = false;
    for (const term of EXCLUDED_FUNCTION_TERMS) {
      if (functionName.search(term) >= 0) {
        isExcludedFunction = true;
        break;
      }
    }

    if (!isExcludedFunction) {
      const docString = methodDocstrings.get(functionName);
      output = output.concat(`\n\n${docString}`);
      output = output.concat(`\t${functionName}(`);
      // add parameters - pull in their name, whether they're optional or not, and their type
      let parametersList = '';
      let argumentsList = '';
      for (let i = 0; i < node.parameters.length; i++) {
        const name = getEscapedText(node.parameters[i].name);
        const questionToken = node.parameters[i].questionToken ? '?' : '';
        const typeString = node.parameters[i].type?.getFullText();
        let parameter = `${name}${questionToken}: ${typeString}`;

        parametersList = parametersList.concat(name);
        // this has to do with function overloading - we will later surface code
        // that does type checking for options and callback
        if (name === 'optionsOrCallback') {
          argumentsList = argumentsList.concat('options');
        } else {
          argumentsList = argumentsList.concat(name);
        }
        if (i !== node.parameters.length - 1) {
          parameter += ',';
          parametersList += ',';
          argumentsList += ',';
        }
        output = output.concat(`\n\t\t${parameter}`);
      }
      output = output.concat(')');

      const returnType = node.type!.getFullText();
      output = output.concat(`:${returnType}`);

      const clientName = parseClientName(client);

      // call underlying client function
      if (node.body) {
        let optionsOrCallback = '';
        if (functionName.endsWith('Stream')) {
          optionsOrCallback = `
          return this.${clientName}.${functionName}(request, options);}`;
        } else if (functionName.endsWith('Async')) {
          optionsOrCallback = `
          return this.${clientName}.${functionName}(request, options);}`;
        } else {
          // this logic needs to be surfaced from underlying clients
          // to make sure our parameters play nicely with underlying overloads
          // otherwise you will run into issues similar to https://github.com/microsoft/TypeScript/issues/1805
          // we also add a check for undefined callback
          optionsOrCallback = `
              request = request || {};
              let options: CallOptions;
              if (typeof optionsOrCallback === 'function' && callback === undefined) {
                  callback = optionsOrCallback;
                  options = {};
              }
              else {
                  options = optionsOrCallback as CallOptions;
              }
              if (callback === undefined){
                return this.${clientName}.${functionName}(request, options);
              }
              return this.${clientName}.${functionName}(${argumentsList});
              }`;
        }
        output = output.concat(`{\n${optionsOrCallback}\n`);
      }
    }
  });

  return output;
}

// loop through the files and call the AST function on them
function astHelper(files: string[], clients: string[]) {
  let output = '';
  for (const f in files) {
    foundNodes = [];
    const client = clients[f].split('Service')[0];
    output = output.concat(ast(files[f], client));
  }
  return output;
}

function makeImports(clients: string[]) {
  let imports = 'import {protos';
  for (const client in clients) {
    imports = imports.concat(`, ${clients[client]}`);
  }

  imports = imports.concat('} from ".";');
  const staticImports = `
  import type * as gax from "google-gax";
  import {Callback, CallOptions, ClientOptions, PaginationCallback} from "google-gax";
  import {Transform} from 'stream';
  `;

  imports = imports.concat(`${staticImports}\n\n`);
  return imports;
}

// convert client types to the names we'll use for variables
function parseClientName(client: string) {
  // without this we'd end up with rowaccesspolicyClient

  return client.search('RowAccessPolicy') >= 0
    ? 'rowAccessPolicyClient'
    : client.split('ServiceClient')[0].toLowerCase() + 'Client';
}

function buildOptionTypes(clients: string[]) {
  let output = '';
  const docstring = `/**
   * Options passed to the underlying client.
   *
   * @param {object} [options] - The configuration object.
   * The options accepted by the constructor are described in detail
   * in [this document](https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#creating-the-client-instance).
   * The common options are:
   * @param {object} [options.credentials] - Credentials object.
   * @param {string} [options.credentials.client_email]
   * @param {string} [options.credentials.private_key]
   * @param {string} [options.email] - Account email address. Required when
   *     using a .pem or .p12 keyFilename.
   * @param {string} [options.keyFilename] - Full path to the a .json, .pem, or
   *     .p12 key downloaded from the Google Developers Console. If you provide
   *     a path to a JSON file, the projectId option below is not necessary.
   *     NOTE: .pem and .p12 require you to specify options.email as well.
   * @param {number} [options.port] - The port on which to connect to
   *     the remote host.
   * @param {string} [options.projectId] - The project ID from the Google
   *     Developer's Console, e.g. 'grape-spaceship-123'. We will also check
   *     the environment variable GCLOUD_PROJECT for your project ID. If your
   *     app is running in an environment which supports
   *     {@link https://cloud.google.com/docs/authentication/application-default-credentials Application Default Credentials},
   *     your project ID will be detected automatically.
   * @param {string} [options.apiEndpoint] - The domain name of the
   *     API remote host.
   * @param {gax.ClientConfig} [options.clientConfig] - Client configuration override.
   *     Follows the structure of {@link gapicConfig}.
   * @param {boolean} [options.fallback] - Use HTTP/1.1 REST mode.
   *     For more information, please check the
   *     {@link https://github.com/googleapis/gax-nodejs/blob/main/client-libraries.md#http11-rest-api-mode documentation}.
   * @param {gax} [gaxInstance]: loaded instance of \`google-gax\`. Useful if you
   *     need to avoid loading the default gRPC version and want to use the fallback
   *     HTTP implementation. Load only fallback version and pass it to the constructor:
   *     \`\`\`
   *     const gax = require('google-gax/build/src/fallback'); // avoids loading google-gax with gRPC
   *     const client = new DatasetServiceClient({fallback: true}, gax);
   *     \`\`\`
   */\n`;

  const subClientOptionsType = `export type SubClientOptions = {opts?: ClientOptions,
    gaxInstance?: typeof gax | typeof gax.fallback};\n\n`;
  output = output.concat(docstring, subClientOptionsType);

  let bigQueryOptionsType = 'export type BigQueryClientOptions = {\n';
  for (const client in clients) {
    let variableDecl = '';
    const clientName = parseClientName(clients[client]);
    variableDecl = variableDecl.concat(
      `\t${clientName}?: ${clients[client]};\n`,
    );
    bigQueryOptionsType = bigQueryOptionsType.concat(variableDecl);
  }
  bigQueryOptionsType = bigQueryOptionsType.concat('};\n\n');
  output = output.concat(bigQueryOptionsType);
  return output;
}

function buildClientConstructor(clients: string[]) {
  let variableDecl = '';
  const comment = `\t/**
  * @param {object} [BigQueryClientOptions] - Enables user to instantiate clients separately and use those as the subclients.
  * @param {object} [SubClientOptions] - These options will be shared across subclients.
  * To have sub-clients with different options, instantiate each client separately.
  */`;
  let constructorInitializers =
    '\tconstructor(options?: BigQueryClientOptions, subClientOptions?: SubClientOptions){\n';
  for (const client in clients) {
    const clientName = parseClientName(clients[client]);
    variableDecl = variableDecl.concat(
      `\t${clientName}: ${clients[client]};\n`,
    );
    constructorInitializers = constructorInitializers.concat(
      `\t\tthis.${clientName} = options?.${clientName} ?? new ${clients[client]}(subClientOptions?.opts, subClientOptions?.gaxInstance);\n`,
    );
  }
  constructorInitializers = constructorInitializers.concat('\t}');
  let output = 'export class BigQueryClient{\n';
  output = output.concat(
    variableDecl,
    '\n',
    comment,
    '\n',
    constructorInitializers,
  );
  return output;
}

// Looks at existing bigquery.ts - all handwritten code MUST be
// in between // Begin handwritten and // End handwritten tags
// or it will be overwritten
function readHandwrittenCode(): string {
  let handwrittenCode = '\n';
  const input = fs.readFileSync('../src/bigquery.ts', 'utf8');
  const startIndex = input.search('// Begin handwritten');
  const endIndex = input.search('// End handwritten') + 18; // +18 includes the comment "end handwritten"
  handwrittenCode = handwrittenCode.concat(input.slice(startIndex, endIndex));
  return handwrittenCode;
}

// first add the components that don't come from underlying files
// (imports, exported types, docstring w/ client constructor)
// then, traverse the file inputs and add the functions from them
async function buildOutput() {
  console.log('Regenerating bigquery.ts');
  let output = '';
  output = LICENSE.concat(makeImports(CLIENTS));
  output = output.concat(buildOptionTypes(CLIENTS));
  output = output.concat(buildClientConstructor(CLIENTS));
  output = output.concat(astHelper(FILES, CLIENTS));
  output = output.concat(readHandwrittenCode());
  output = output.concat('\n}');
  return prettier.format(output, {
    parser: 'typescript',
    trailingComma: 'all',
    singleQuote: true,
    bracketSpacing: false,
  });
}
async function main() {
  const finaloutput = await buildOutput();
  fs.writeFile('../src/bigquery.ts', finaloutput, err => {
    if (err) throw err;
  });
}

main().catch(err => console.error(err));
