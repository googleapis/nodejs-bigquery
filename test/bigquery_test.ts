// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// ** This file is automatically generated by gapic-generator-typescript. **
// ** https://github.com/googleapis/gapic-generator-typescript **
// ** All changes to this file may be overwritten. **

import {
  BigQueryClient,
  BigQueryClientOptions,
  SubClientOptions,
} from '../src/bigquery';

import * as protos from '../protos/protos';
import * as assert from 'assert';
import * as sinon from 'sinon';
import {describe, it} from 'mocha';
import {
  DatasetServiceClient,
  TableServiceClient,
  RowAccessPolicyServiceClient,
  ModelServiceClient,
  JobServiceClient,
  RoutineServiceClient,
} from '../src';
import {PassThrough, Transform} from 'stream';

// this test assumes that the npm "pretest" session has been run
// and the client was regenerated immediately before these tests are run
describe('BigQueryClient has the number of clients and methods we expect', () => {
  it('should have six client attributes', () => {
    const client = new BigQueryClient();
    assert.equal(Object.getOwnPropertyNames(client).length, 6);
  });
  it('should have 42 methods including the constructor', () => {
    const client = new BigQueryClient();
    assert.equal(
      Object.getOwnPropertyNames(Object.getPrototypeOf(client)).length,
      42
    );
  });
});
describe('BigQueryClient should be able to handle passing in clients and options', () => {
  const subOptions: SubClientOptions = {
    opts: {
      universeDomain: 'fake-universe-domain',
    },
  };
  it('creates a central client using clients we pass in', () => {
    const datasetClient = new DatasetServiceClient(subOptions.opts);
    const tableClient = new TableServiceClient(subOptions.opts);
    const jobClient = new JobServiceClient(subOptions.opts);
    const routineClient = new RoutineServiceClient(subOptions.opts);
    const modelClient = new ModelServiceClient(subOptions.opts);
    const rowaccesspolicyClient = new RowAccessPolicyServiceClient(
      subOptions.opts
    );
    const options: BigQueryClientOptions = {
      datasetClient: datasetClient,
      tableClient: tableClient,
      jobClient: jobClient,
      routineClient: routineClient,
      modelClient: modelClient,
      rowaccesspolicyClient: rowaccesspolicyClient,
    };
    const client = new BigQueryClient(options);
    assert.ok(client);
    assert.deepStrictEqual(
      client.datasetClient.apiEndpoint,
      'bigquery.fake-universe-domain'
    );
    assert.deepStrictEqual(
      client.tableClient.apiEndpoint,
      'bigquery.fake-universe-domain'
    );
    assert.deepStrictEqual(
      client.jobClient.apiEndpoint,
      'bigquery.fake-universe-domain'
    );
    assert.deepStrictEqual(
      client.routineClient.apiEndpoint,
      'bigquery.fake-universe-domain'
    );
    assert.deepStrictEqual(
      client.modelClient.apiEndpoint,
      'bigquery.fake-universe-domain'
    );
    assert.deepStrictEqual(
      client.rowaccesspolicyClient.apiEndpoint,
      'bigquery.fake-universe-domain'
    );
  });
  it('creates a central client using default clients and suboptions we pass in', () => {
    const client = new BigQueryClient({}, subOptions);
    assert.ok(client);
    assert.deepStrictEqual(
      client.datasetClient.apiEndpoint,
      'bigquery.fake-universe-domain'
    );
    assert.deepStrictEqual(
      client.tableClient.apiEndpoint,
      'bigquery.fake-universe-domain'
    );
    assert.deepStrictEqual(
      client.jobClient.apiEndpoint,
      'bigquery.fake-universe-domain'
    );
    assert.deepStrictEqual(
      client.routineClient.apiEndpoint,
      'bigquery.fake-universe-domain'
    );
    assert.deepStrictEqual(
      client.modelClient.apiEndpoint,
      'bigquery.fake-universe-domain'
    );
    assert.deepStrictEqual(
      client.rowaccesspolicyClient.apiEndpoint,
      'bigquery.fake-universe-domain'
    );
  });
});

// It is not important that these unit tests validate the responses
// underlying client unit tests will do that - it is only important that
// we validate the connection between the BigQuery client and the methods it calls
describe('BigQueryClient should call underlying client methods asynchronously', () => {
  const client = new BigQueryClient();
  describe('BigQuery client should call underlying methods in the Dataset Client', () => {
    after(() => {
      sinon.restore();
    });
    it('should call getDataset', async () => {
      const datasetRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
      } as protos.google.cloud.bigquery.v2.IGetDatasetRequest;
      const getStub = sinon
        .stub(client.datasetClient, 'getDataset')
        .resolves('FakeDataset');
      await client.getDataset(datasetRequest);
      assert.ok(getStub.calledOnce);
    });
    it('should call insertDataset', async () => {
      const datasetRequest = {
        projectId: 'projectId',
        dataset: {datasetReference: {datasetId: 'datasetId'}},
      } as protos.google.cloud.bigquery.v2.IInsertDatasetRequest;
      const insertStub = sinon
        .stub(client.datasetClient, 'insertDataset')
        .resolves('FakeDataset');
      await client.insertDataset(datasetRequest);
      assert.ok(insertStub.calledOnce);
    });
    it('should call undeleteDataset', async () => {
      const datasetRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
      } as protos.google.cloud.bigquery.v2.IUndeleteDatasetRequest;
      const undeleteStub = sinon
        .stub(client.datasetClient, 'undeleteDataset')
        .resolves('FakeDataset');
      await client.undeleteDataset(datasetRequest);
      assert.ok(undeleteStub.calledOnce);
    });
    it('should call listDatasets', async () => {
      const datasetRequest = {
        projectId: 'projectId',
      } as protos.google.cloud.bigquery.v2.IListDatasetsRequest;
      const listStub = sinon
        .stub(client.datasetClient, 'listDatasets')
        .resolves('FakeDatasetList');
      await client.listDatasets(datasetRequest);
      assert.ok(listStub.calledOnce);
    });
    it('should call listDatasetsStream', async () => {
      const datasetRequest = {
        projectId: 'projectId',
      } as protos.google.cloud.bigquery.v2.IListDatasetsRequest;
      const listStub = sinon
        .stub(client.datasetClient, 'listDatasetsStream')
        .resolves('FakeDatasetListStream');
      
      await client.listDatasetsStream(datasetRequest);
      assert.ok(listStub.calledOnce);
    });
    it('should call listDatasetsAsync', async () => {
      const datasetRequest = {
        projectId: 'projectId',
      } as protos.google.cloud.bigquery.v2.IListDatasetsRequest;
      const listStub = sinon
        .stub(client.datasetClient, 'listDatasetsAsync')
        .resolves('FakeDatasetListIterable');
      
      await client.listDatasetsAsync(datasetRequest);
      assert.ok(listStub.calledOnce);
    });

    it('should call patchDataset', async () => {
      const datasetRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        dataset: {datasetReference: {datasetId: 'datasetId'}},
      } as protos.google.cloud.bigquery.v2.IUpdateOrPatchDatasetRequest;
      const patchStub = sinon
        .stub(client.datasetClient, 'patchDataset')
        .resolves('FakeDataset');
      await client.patchDataset(datasetRequest);
      assert.ok(patchStub.calledOnce);
    });

    it('should call updateDataset', async () => {
      const datasetRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        dataset: {datasetReference: {datasetId: 'datasetId'}},
      } as protos.google.cloud.bigquery.v2.IUpdateOrPatchDatasetRequest;
      const updateStub = sinon
        .stub(client.datasetClient, 'updateDataset')
        .resolves('Dataset');
      await client.updateDataset(datasetRequest);
      assert.ok(updateStub.calledOnce);
    });
    it('should call deleteDataset', async () => {
      const datasetRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
      } as protos.google.cloud.bigquery.v2.IDeleteDatasetRequest;
      const deleteStub = sinon
        .stub(client.datasetClient, 'deleteDataset')
        .resolves({});
      await client.deleteDataset(datasetRequest);
      assert.ok(deleteStub.calledOnce);
    });
  });

  describe('BigQuery client should call underlying methods in the Job Client', () => {
    after(() => {
      sinon.restore();
    });
    it('should call getJob', async () => {
      const jobRequest = {
        projectId: 'projectId',
        jobId: 'jobId',
      } as protos.google.cloud.bigquery.v2.IGetJobRequest;
      const getStub = sinon
        .stub(client.jobClient, 'getJob')
        .resolves('FakeJob');
      await client.getJob(jobRequest);
      assert.ok(getStub.calledOnce);
    });

    it('should call insertJob', async () => {
      const jobRequest = {
        projectId: 'projectId', // Add required fields to the request
        job: {}, // Add required fields to the job object if needed
      } as protos.google.cloud.bigquery.v2.IInsertJobRequest;
      const insertStub = sinon
        .stub(client.jobClient, 'insertJob')
        .resolves('FakeJob');
      await client.insertJob(jobRequest);
      assert.ok(insertStub.calledOnce);
    });

    it('should call cancelJob', async () => {
      const jobRequest = {
        projectId: 'projectId',
        jobId: 'jobId',
      } as protos.google.cloud.bigquery.v2.ICancelJobRequest;
      const cancelStub = sinon
        .stub(client.jobClient, 'cancelJob')
        .resolves('FakeJob');
      await client.cancelJob(jobRequest);
      assert.ok(cancelStub.calledOnce);
    });

    it('should call deleteJob', async () => {
      const jobRequest = {
        projectId: 'projectId',
        jobId: 'jobId',
      } as protos.google.cloud.bigquery.v2.IDeleteJobRequest;
      const deleteStub = sinon.stub(client.jobClient, 'deleteJob').resolves({});
      await client.deleteJob(jobRequest);
      assert.ok(deleteStub.calledOnce);
    });
    it('should call listJobs', async () => {
      const jobRequest = {
        projectId: 'projectId',
      } as protos.google.cloud.bigquery.v2.IListJobsRequest;
      const listStub = sinon
        .stub(client.jobClient, 'listJobs')
        .resolves('FakeJobsList');
      await client.listJobs(jobRequest);
      assert.ok(listStub.calledOnce);
    });
    it('should call listJobsStream', async () => {
      const jobRequest = {
        projectId: 'projectId',
      } as protos.google.cloud.bigquery.v2.IListJobsRequest;
      const listStub = sinon
        .stub(client.jobClient, 'listJobsStream')
        .resolves('FakeJobListStream');
      
      await client.listJobsStream(jobRequest);
      assert.ok(listStub.calledOnce);
    });
    it('should call listJobsAsync', async () => {
      const jobRequest = {
        projectId: 'projectId',
      } as protos.google.cloud.bigquery.v2.IListJobsRequest;
      const listStub = sinon
        .stub(client.jobClient, 'listJobsAsync')
        .resolves('FakeJobListIterable');
      
      await client.listJobsAsync(jobRequest);
      assert.ok(listStub.calledOnce);
    });
  });

  describe('BigQuery client should call underlying methods in the Model Client', () => {
    after(() => {
      sinon.restore();
    });

    it('should call getModel', async () => {
      const modelRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        modelId: 'modelId',
      } as protos.google.cloud.bigquery.v2.IGetModelRequest;
      const getStub = sinon
        .stub(client.modelClient, 'getModel')
        .resolves('FakeModel');
      await client.getModel(modelRequest);
      assert.ok(getStub.calledOnce);
    });

    it('should call patchModel', async () => {
      const modelRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        modelId: 'modelId',
        model: {modelReference: {modelId: 'modelId'}}, // Add required fields
      } as protos.google.cloud.bigquery.v2.IPatchModelRequest;
      const patchStub = sinon
        .stub(client.modelClient, 'patchModel')
        .resolves('FakeModel');
      await client.patchModel(modelRequest);
      assert.ok(patchStub.calledOnce);
    });

    it('should call deleteModel', async () => {
      const modelRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        modelId: 'modelId',
      } as protos.google.cloud.bigquery.v2.IDeleteModelRequest;
      const deleteStub = sinon
        .stub(client.modelClient, 'deleteModel')
        .resolves({});
      await client.deleteModel(modelRequest);
      assert.ok(deleteStub.calledOnce);
    });

    it('should call listModels', async () => {
      const modelRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
      } as protos.google.cloud.bigquery.v2.IListModelsRequest;
      const listStub = sinon
        .stub(client.modelClient, 'listModels')
        .resolves('FakeModels');
      await client.listModels(modelRequest);
      assert.ok(listStub.calledOnce);
    });
    it('should call listModelsStream', async () => {
      const modelRequest = {
        projectId: 'projectId',
      } as protos.google.cloud.bigquery.v2.IListModelsRequest;
      const listStub = sinon
        .stub(client.modelClient, 'listModelsStream')
        .resolves('FakeModelListStream');
      
      await client.listModelsStream(modelRequest);
      assert.ok(listStub.calledOnce);
    });
    it('should call listModelsAsync', async () => {
      const modelRequest = {
        projectId: 'projectId',
      } as protos.google.cloud.bigquery.v2.IListModelsRequest;
      const listStub = sinon
        .stub(client.modelClient, 'listModelsAsync')
        .resolves('FakeModelListIterable');
      
      await client.listModelsAsync(modelRequest);
      assert.ok(listStub.calledOnce);
    });
  });
  describe('BigQuery client should call underlying methods in the Routine Client', () => {
    after(() => {
      sinon.restore();
    });

    it('should call getRoutine', async () => {
      const routineRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        routineId: 'routineId',
      } as protos.google.cloud.bigquery.v2.IGetRoutineRequest;
      const getStub = sinon
        .stub(client.routineClient, 'getRoutine')
        .resolves('FakeRoutine');
      await client.getRoutine(routineRequest);
      assert.ok(getStub.calledOnce);
    });

    it('should call insertRoutine', async () => {
      const routineRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        routine: {routineReference: {routineId: 'routineId'}}, // Add required fields
      } as protos.google.cloud.bigquery.v2.IInsertRoutineRequest;
      const insertStub = sinon
        .stub(client.routineClient, 'insertRoutine')
        .resolves('FakeRoutine');
      await client.insertRoutine(routineRequest);
      assert.ok(insertStub.calledOnce);
    });

    it('should call updateRoutine', async () => {
      const routineRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        routineId: 'routineId',
        routine: {routineReference: {routineId: 'routineId'}}, // Add required fields
      } as protos.google.cloud.bigquery.v2.IUpdateRoutineRequest;
      const updateStub = sinon
        .stub(client.routineClient, 'updateRoutine')
        .resolves('FakeRoutine');
      await client.updateRoutine(routineRequest);
      assert.ok(updateStub.calledOnce);
    });

    it('should call patchRoutine', async () => {
      const routineRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        routineId: 'routineId',
        routine: {routineReference: {routineId: 'routineId'}}, // Add required fields
      } as protos.google.cloud.bigquery.v2.IPatchRoutineRequest;
      const patchStub = sinon
        .stub(client.routineClient, 'patchRoutine')
        .resolves('FakeRoutine');
      await client.patchRoutine(routineRequest);
      assert.ok(patchStub.calledOnce);
    });

    it('should call deleteRoutine', async () => {
      const routineRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        routineId: 'routineId',
      } as protos.google.cloud.bigquery.v2.IDeleteRoutineRequest;
      const deleteStub = sinon
        .stub(client.routineClient, 'deleteRoutine')
        .resolves({});
      await client.deleteRoutine(routineRequest);
      assert.ok(deleteStub.calledOnce);
    });

    it('should call listRoutines', async () => {
      const routineRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
      } as protos.google.cloud.bigquery.v2.IListRoutinesRequest;
      const listStub = sinon
        .stub(client.routineClient, 'listRoutines')
        .resolves('FakeRoutines');
      await client.listRoutines(routineRequest);
      assert.ok(listStub.calledOnce);
    });
    it('should call listRoutinesStream', async () => {
      const routineRequest = {
        projectId: 'projectId',
      } as protos.google.cloud.bigquery.v2.IListRoutinesRequest;
      const listStub = sinon
        .stub(client.routineClient, 'listRoutinesStream')
        .resolves('FakeRoutineListStream');
      
      await client.listRoutinesStream(routineRequest);
      assert.ok(listStub.calledOnce);
    });
    it('should call listRoutinesAsync', async () => {
      const routineRequest = {
        projectId: 'projectId',
      } as protos.google.cloud.bigquery.v2.IListRoutinesRequest;
      const listStub = sinon
        .stub(client.routineClient, 'listRoutinesAsync')
        .resolves('FakeRoutineListIterable');
      
      await client.listRoutinesAsync(routineRequest);
      assert.ok(listStub.calledOnce);
    });
  });

  describe('BigQuery client should call underlying methods in the Table Client', () => {
    after(() => {
      sinon.restore();
    });

    it('should call getTable', async () => {
      const tableRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        tableId: 'tableId',
      } as protos.google.cloud.bigquery.v2.IGetTableRequest;
      const getStub = sinon
        .stub(client.tableClient, 'getTable')
        .resolves('FakeTable');
      await client.getTable(tableRequest);
      assert.ok(getStub.calledOnce);
    });

    it('should call insertTable', async () => {
      const tableRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        table: {tableReference: {tableId: 'tableId'}}, // Add required fields
      } as protos.google.cloud.bigquery.v2.IInsertTableRequest;
      const insertStub = sinon
        .stub(client.tableClient, 'insertTable')
        .resolves('FakeTable');
      await client.insertTable(tableRequest);
      assert.ok(insertStub.calledOnce);
    });

    it('should call updateTable', async () => {
      const tableRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        tableId: 'tableId',
        table: {tableReference: {tableId: 'tableId'}}, // Add required fields
      } as protos.google.cloud.bigquery.v2.IUpdateOrPatchTableRequest;
      const updateStub = sinon
        .stub(client.tableClient, 'updateTable')
        .resolves('FakeTable');
      await client.updateTable(tableRequest);
      assert.ok(updateStub.calledOnce);
    });

    it('should call patchTable', async () => {
      const tableRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        tableId: 'tableId',
        table: {tableReference: {tableId: 'tableId'}}, // Add required fields
      } as protos.google.cloud.bigquery.v2.IUpdateOrPatchTableRequest;
      const patchStub = sinon
        .stub(client.tableClient, 'patchTable')
        .resolves('FakeTable');
      await client.patchTable(tableRequest);
      assert.ok(patchStub.calledOnce);
    });

    it('should call deleteTable', async () => {
      const tableRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        tableId: 'tableId',
      } as protos.google.cloud.bigquery.v2.IDeleteTableRequest;
      const deleteStub = sinon
        .stub(client.tableClient, 'deleteTable')
        .resolves({});
      await client.deleteTable(tableRequest);
      assert.ok(deleteStub.calledOnce);
    });

    it('should call listTables', async () => {
      const tableRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
      } as protos.google.cloud.bigquery.v2.IListTablesRequest;
      const listStub = sinon
        .stub(client.tableClient, 'listTables')
        .resolves('FakeTableList');
      await client.listTables(tableRequest);
      assert.ok(listStub.calledOnce);
    });
    it('should call listTablesStream', async () => {
      const tableRequest = {
        projectId: 'projectId',
      } as protos.google.cloud.bigquery.v2.IListTablesRequest;
      const listStub = sinon
        .stub(client.tableClient, 'listTablesStream')
        .resolves('FakeTableListStream');
      
      await client.listTablesStream(tableRequest);
      assert.ok(listStub.calledOnce);
    });
    it('should call listTablesAsync', async () => {
      const tableRequest = {
        projectId: 'projectId',
      } as protos.google.cloud.bigquery.v2.IListTablesRequest;
      const listStub = sinon
        .stub(client.tableClient, 'listTablesAsync')
        .resolves('FakeTableListIterable');
      
      await client.listTablesAsync(tableRequest);
      assert.ok(listStub.calledOnce);
    });
  });
  // TODO update with stream/async

  describe('BigQuery client should call underlying methods in the Row Access Policy Client', () => {
    after(() => {
      sinon.restore();
    });
    it('should call listRowAccessPolicies', async () => {
      const rowAccessPolicyRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        tableId: 'tableId', // Ensure all required fields are present
      } as protos.google.cloud.bigquery.v2.IListRowAccessPoliciesRequest;
      const listStub = sinon
        .stub(client.rowaccesspolicyClient, 'listRowAccessPolicies')
        .resolves('FakeRowAccessPoliciesList');
      await client.listRowAccessPolicies(rowAccessPolicyRequest);
      assert.ok(listStub.calledOnce);
    });
    it('should call listRowAccessPoliciesStream', async () => {
      const rowAccessPoliciesRequest = {
        projectId: 'projectId',
      } as protos.google.cloud.bigquery.v2.IListRowAccessPoliciesRequest;
      const listStub = sinon
        .stub(client.rowaccesspolicyClient, 'listRowAccessPoliciesStream')
        .resolves('FakeRowAccessPoliciesListStream');
      
      await client.listRowAccessPoliciesStream(rowAccessPoliciesRequest);
      assert.ok(listStub.calledOnce);
    });
    it('should call listRowAccessPoliciesAsync', async () => {
      const rowAccessPoliciesRequest = {
        projectId: 'projectId',
      } as protos.google.cloud.bigquery.v2.IListRowAccessPoliciesRequest;
      const listStub = sinon
        .stub(client.rowaccesspolicyClient, 'listRowAccessPoliciesAsync')
        .resolves('FakeRowAccessPoliciesListIterable');
      
      await client.listRowAccessPoliciesAsync(rowAccessPoliciesRequest);
      assert.ok(listStub.calledOnce);
    });
  });
});

describe('BigQueryClient should call underlying client methods synchronously', () => {
  const client = new BigQueryClient();

  describe('BigQuery client should call underlying methods in the Dataset Client', () => {
    after(() => {
      sinon.restore();
    });
    it('should call getDataset', () => {
      const datasetRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
      } as protos.google.cloud.bigquery.v2.IGetDatasetRequest;
      const getStub = sinon
        .stub(client.datasetClient, 'getDataset')
        .callsArgWith(2, null, 'FakeDataset');
      const resp = client.getDataset(datasetRequest, {}, (err, response) => {
        if (err) {
          throw err;
        }
        return response + ' called back';
      });
      assert.ok(getStub.calledOnce);
      assert.strictEqual('FakeDataset called back', resp);
    });
    it('should call insertDataset', async () => {
      const datasetRequest = {
        projectId: 'projectId',
        dataset: {datasetReference: {datasetId: 'datasetId'}},
      } as protos.google.cloud.bigquery.v2.IInsertDatasetRequest;
      const insertStub = sinon
        .stub(client.datasetClient, 'insertDataset')
        .callsArgWith(2, null, 'FakeDataset');
      const resp = client.insertDataset(datasetRequest, {}, (err, response) => {
        if (err) {
          throw err;
        }
        return response + ' called back';
      });
      assert.ok(insertStub.calledOnce);

      assert.strictEqual('FakeDataset called back', resp);
    });
    it('should call undeleteDataset', async () => {
      const datasetRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
      } as protos.google.cloud.bigquery.v2.IUndeleteDatasetRequest;
      const undeleteStub = sinon
        .stub(client.datasetClient, 'undeleteDataset')
        .callsArgWith(2, null, 'FakeDataset');
      const resp = client.undeleteDataset(
        datasetRequest,
        {},
        (err, response) => {
          if (err) {
            throw err;
          }
          return response + ' called back';
        }
      );
      assert.ok(undeleteStub.calledOnce);
      assert.strictEqual('FakeDataset called back', resp);
    });

    it('should call listDatasets', async () => {
      const datasetRequest = {
        projectId: 'projectId',
      } as protos.google.cloud.bigquery.v2.IListDatasetsRequest;
      const listStub = sinon
        .stub(client.datasetClient, 'listDatasets')
        .callsArgWith(2, null, 'FakeDatasetList');
      const resp = client.listDatasets(datasetRequest, {}, (err, response) => {
        if (err) {
          throw err;
        }
        return response + ' called back';
      });
      assert.ok(listStub.calledOnce);
      assert.strictEqual('FakeDatasetList called back', resp);
    });

    it('should call patchDataset', async () => {
      const datasetRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        dataset: {datasetReference: {datasetId: 'datasetId'}},
      } as protos.google.cloud.bigquery.v2.IUpdateOrPatchDatasetRequest;
      const patchStub = sinon
        .stub(client.datasetClient, 'patchDataset')
        .callsArgWith(2, null, 'FakeDataset');
      const resp = client.patchDataset(datasetRequest, {}, (err, response) => {
        if (err) {
          throw err;
        }
        return response + ' called back';
      });
      assert.ok(patchStub.calledOnce);
      assert.strictEqual('FakeDataset called back', resp);
    });

    it('should call updateDataset', async () => {
      const datasetRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        dataset: {datasetReference: {datasetId: 'datasetId'}},
      } as protos.google.cloud.bigquery.v2.IUpdateOrPatchDatasetRequest;
      const updateStub = sinon
        .stub(client.datasetClient, 'updateDataset')
        .callsArgWith(2, null, 'FakeDataset');
      const resp = client.updateDataset(datasetRequest, {}, (err, response) => {
        if (err) {
          throw err;
        }
        return response + ' called back';
      });
      assert.ok(updateStub.calledOnce);
      assert.strictEqual('FakeDataset called back', resp);
    });
    it('should call deleteDataset', async () => {
      const datasetRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
      } as protos.google.cloud.bigquery.v2.IDeleteDatasetRequest;
      const deleteStub = sinon
        .stub(client.datasetClient, 'deleteDataset')
        .callsArgWith(2, null, 'FakeDataset');
      const resp = client.deleteDataset(datasetRequest, {}, (err, response) => {
        if (err) {
          throw err;
        }
        return response + ' called back';
      });
      assert.ok(deleteStub.calledOnce);
      assert.strictEqual('FakeDataset called back', resp);
    });
  });

  describe('BigQuery client should call underlying methods in the Job Client', () => {
    after(() => {
      sinon.restore();
    });
    it('should call getJob', async () => {
      const jobRequest = {
        projectId: 'projectId',
        jobId: 'jobId',
      } as protos.google.cloud.bigquery.v2.IGetJobRequest;
      const getStub = sinon
        .stub(client.jobClient, 'getJob')
        .callsArgWith(2, null, 'FakeJob');
      const resp = client.getJob(jobRequest, {}, (err, response) => {
        if (err) {
          throw err;
        }
        return response + ' called back';
      });
      assert.ok(getStub.calledOnce);
      assert.strictEqual('FakeJob called back', resp);
    });

    it('should call insertJob', async () => {
      const jobRequest = {
        projectId: 'projectId', // Add required fields to the request
        job: {}, // Add required fields to the job object if needed
      } as protos.google.cloud.bigquery.v2.IInsertJobRequest;
      const insertStub = sinon
        .stub(client.jobClient, 'insertJob')
        .callsArgWith(2, null, 'FakeJob');
      const resp = client.insertJob(jobRequest, {}, (err, response) => {
        if (err) {
          throw err;
        }
        return response + ' called back';
      });
      assert.ok(insertStub.calledOnce);
      assert.strictEqual('FakeJob called back', resp);
    });

    it('should call cancelJob', async () => {
      const jobRequest = {
        projectId: 'projectId',
        jobId: 'jobId',
      } as protos.google.cloud.bigquery.v2.ICancelJobRequest;
      const cancelStub = sinon
        .stub(client.jobClient, 'cancelJob')
        .callsArgWith(2, null, 'FakeJob');
      const resp = client.cancelJob(jobRequest, {}, (err, response) => {
        if (err) {
          throw err;
        }
        return response + ' called back';
      });
      assert.ok(cancelStub.calledOnce);
      assert.strictEqual('FakeJob called back', resp);
    });

    it('should call deleteJob', async () => {
      const jobRequest = {
        projectId: 'projectId',
        jobId: 'jobId',
      } as protos.google.cloud.bigquery.v2.IDeleteJobRequest;
      const deleteStub = sinon
        .stub(client.jobClient, 'deleteJob')
        .callsArgWith(2, null, 'FakeJob');
      const resp = client.deleteJob(jobRequest, {}, (err, response) => {
        if (err) {
          throw err;
        }
        return response + ' called back';
      });
      assert.ok(deleteStub.calledOnce);
      assert.strictEqual('FakeJob called back', resp);
    });
    it('should call listJobs', async () => {
      const jobRequest = {
        projectId: 'projectId',
      } as protos.google.cloud.bigquery.v2.IListJobsRequest;
      const listStub = sinon
        .stub(client.jobClient, 'listJobs')
        .callsArgWith(2, null, 'FakeJob');
      const resp = client.listJobs(jobRequest, {}, (err, response) => {
        if (err) {
          throw err;
        }
        return response + ' called back';
      });
      assert.ok(listStub.calledOnce);
      assert.strictEqual('FakeJob called back', resp);
    });
  });

  describe('BigQuery client should call underlying methods in the Model Client', () => {
    after(() => {
      sinon.restore();
    });

    it('should call getModel', async () => {
      const modelRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        modelId: 'modelId',
      } as protos.google.cloud.bigquery.v2.IGetModelRequest;
      const getStub = sinon
        .stub(client.modelClient, 'getModel')
        .callsArgWith(2, null, 'FakeModel');
      const resp = client.getModel(modelRequest, {}, (err, response) => {
        if (err) {
          throw err;
        }
        return response + ' called back';
      });
      assert.ok(getStub.calledOnce);
      assert.strictEqual('FakeModel called back', resp);
    });

    it('should call patchModel', async () => {
      const modelRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        modelId: 'modelId',
        model: {modelReference: {modelId: 'modelId'}}, // Add required fields
      } as protos.google.cloud.bigquery.v2.IPatchModelRequest;
      const patchStub = sinon
        .stub(client.modelClient, 'patchModel')
        .callsArgWith(2, null, 'FakeModel');
      const resp = client.patchModel(modelRequest, {}, (err, response) => {
        if (err) {
          throw err;
        }
        return response + ' called back';
      });
      assert.ok(patchStub.calledOnce);
      assert.strictEqual('FakeModel called back', resp);
    });

    it('should call deleteModel', async () => {
      const modelRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        modelId: 'modelId',
      } as protos.google.cloud.bigquery.v2.IDeleteModelRequest;
      const deleteStub = sinon
        .stub(client.modelClient, 'deleteModel')
        .callsArgWith(2, null, 'FakeModel');
      const resp = client.deleteModel(modelRequest, {}, (err, response) => {
        if (err) {
          throw err;
        }
        return response + ' called back';
      });
      assert.ok(deleteStub.calledOnce);
      assert.strictEqual('FakeModel called back', resp);
    });

    it('should call listModels', async () => {
      const modelRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
      } as protos.google.cloud.bigquery.v2.IListModelsRequest;
      const listStub = sinon
        .stub(client.modelClient, 'listModels')
        .callsArgWith(2, null, 'FakeModel');
      const resp = client.listModels(modelRequest, {}, (err, response) => {
        if (err) {
          throw err;
        }
        return response + ' called back';
      });
      assert.ok(listStub.calledOnce);
      assert.strictEqual('FakeModel called back', resp);
    });
  });

  describe('BigQuery client should call underlying methods in the Routine Client', () => {
    after(() => {
      sinon.restore();
    });

    it('should call getRoutine', async () => {
      const routineRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        routineId: 'routineId',
      } as protos.google.cloud.bigquery.v2.IGetRoutineRequest;
      const getStub = sinon
        .stub(client.routineClient, 'getRoutine')
        .callsArgWith(2, null, 'FakeRoutine');
      const resp = client.getRoutine(routineRequest, {}, (err, response) => {
        if (err) {
          throw err;
        }
        return response + ' called back';
      });
      assert.ok(getStub.calledOnce);
      assert.strictEqual('FakeRoutine called back', resp);
    });

    it('should call insertRoutine', async () => {
      const routineRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        routine: {routineReference: {routineId: 'routineId'}}, // Add required fields
      } as protos.google.cloud.bigquery.v2.IInsertRoutineRequest;
      const insertStub = sinon
        .stub(client.routineClient, 'insertRoutine')
        .callsArgWith(2, null, 'FakeRoutine');
      const resp = client.insertRoutine(routineRequest, {}, (err, response) => {
        if (err) {
          throw err;
        }
        return response + ' called back';
      });
      assert.ok(insertStub.calledOnce);
      assert.strictEqual('FakeRoutine called back', resp);
    });

    it('should call updateRoutine', async () => {
      const routineRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        routineId: 'routineId',
        routine: {routineReference: {routineId: 'routineId'}}, // Add required fields
      } as protos.google.cloud.bigquery.v2.IUpdateRoutineRequest;
      const updateStub = sinon
        .stub(client.routineClient, 'updateRoutine')
        .callsArgWith(2, null, 'FakeRoutine');
      const resp = client.updateRoutine(routineRequest, {}, (err, response) => {
        if (err) {
          throw err;
        }
        return response + ' called back';
      });
      assert.ok(updateStub.calledOnce);
      assert.strictEqual('FakeRoutine called back', resp);
    });

    it('should call patchRoutine', async () => {
      const routineRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        routineId: 'routineId',
        routine: {routineReference: {routineId: 'routineId'}}, // Add required fields
      } as protos.google.cloud.bigquery.v2.IPatchRoutineRequest;
      const patchStub = sinon
        .stub(client.routineClient, 'patchRoutine')
        .callsArgWith(2, null, 'FakeRoutine');
      const resp = client.patchRoutine(routineRequest, {}, (err, response) => {
        if (err) {
          throw err;
        }
        return response + ' called back';
      });
      assert.ok(patchStub.calledOnce);
      assert.strictEqual('FakeRoutine called back', resp);
    });

    it('should call deleteRoutine', async () => {
      const routineRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        routineId: 'routineId',
      } as protos.google.cloud.bigquery.v2.IDeleteRoutineRequest;
      const deleteStub = sinon
        .stub(client.routineClient, 'deleteRoutine')
        .callsArgWith(2, null, 'FakeRoutine');
      const resp = client.deleteRoutine(routineRequest, {}, (err, response) => {
        if (err) {
          throw err;
        }
        return response + ' called back';
      });
      assert.ok(deleteStub.calledOnce);
      assert.strictEqual('FakeRoutine called back', resp);
    });

    it('should call listRoutines', async () => {
      const routineRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
      } as protos.google.cloud.bigquery.v2.IListRoutinesRequest;
      const listStub = sinon
        .stub(client.routineClient, 'listRoutines')
        .callsArgWith(2, null, 'FakeRoutine');
      const resp = client.listRoutines(routineRequest, {}, (err, response) => {
        if (err) {
          throw err;
        }
        return response + ' called back';
      });
      assert.ok(listStub.calledOnce);
      assert.strictEqual('FakeRoutine called back', resp);
    });
  });

  describe('BigQuery client should call underlying methods in the Table Client', () => {
    after(() => {
      sinon.restore();
    });

    it('should call getTable', async () => {
      const tableRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        tableId: 'tableId',
      } as protos.google.cloud.bigquery.v2.IGetTableRequest;
      const getStub = sinon
        .stub(client.tableClient, 'getTable')
        .callsArgWith(2, null, 'FakeTable');
      const resp = client.getTable(tableRequest, {}, (err, response) => {
        if (err) {
          throw err;
        }
        return response + ' called back';
      });
      assert.ok(getStub.calledOnce);
      assert.strictEqual('FakeTable called back', resp);
    });

    it('should call insertTable', async () => {
      const tableRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        table: {tableReference: {tableId: 'tableId'}}, // Add required fields
      } as protos.google.cloud.bigquery.v2.IInsertTableRequest;
      const insertStub = sinon
        .stub(client.tableClient, 'insertTable')
        .callsArgWith(2, null, 'FakeTable');
      const resp = client.insertTable(tableRequest, {}, (err, response) => {
        if (err) {
          throw err;
        }
        return response + ' called back';
      });
      assert.ok(insertStub.calledOnce);
      assert.strictEqual('FakeTable called back', resp);
    });

    it('should call updateTable', async () => {
      const tableRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        tableId: 'tableId',
        table: {tableReference: {tableId: 'tableId'}}, // Add required fields
      } as protos.google.cloud.bigquery.v2.IUpdateOrPatchTableRequest;
      const updateStub = sinon
        .stub(client.tableClient, 'updateTable')
        .callsArgWith(2, null, 'FakeTable');
      const resp = client.updateTable(tableRequest, {}, (err, response) => {
        if (err) {
          throw err;
        }
        return response + ' called back';
      });
      assert.ok(updateStub.calledOnce);
      assert.strictEqual('FakeTable called back', resp);
    });

    it('should call patchTable', async () => {
      const tableRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        tableId: 'tableId',
        table: {tableReference: {tableId: 'tableId'}}, // Add required fields
      } as protos.google.cloud.bigquery.v2.IUpdateOrPatchTableRequest;
      const patchStub = sinon
        .stub(client.tableClient, 'patchTable')
        .callsArgWith(2, null, 'FakeTable');
      const resp = client.patchTable(tableRequest, {}, (err, response) => {
        if (err) {
          throw err;
        }
        return response + ' called back';
      });
      assert.ok(patchStub.calledOnce);
      assert.strictEqual('FakeTable called back', resp);
    });

    it('should call deleteTable', async () => {
      const tableRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        tableId: 'tableId',
      } as protos.google.cloud.bigquery.v2.IDeleteTableRequest;
      const deleteStub = sinon
        .stub(client.tableClient, 'deleteTable')
        .callsArgWith(2, null, 'FakeTable');
      const resp = client.deleteTable(tableRequest, {}, (err, response) => {
        if (err) {
          throw err;
        }
        return response + ' called back';
      });
      assert.ok(deleteStub.calledOnce);
      assert.strictEqual('FakeTable called back', resp);
    });

    it('should call listTables', async () => {
      const tableRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
      } as protos.google.cloud.bigquery.v2.IListTablesRequest;
      const listStub = sinon
        .stub(client.tableClient, 'listTables')
        .callsArgWith(2, null, 'FakeTable');
      const resp = client.listTables(tableRequest, {}, (err, response) => {
        if (err) {
          throw err;
        }
        return response + ' called back';
      });
      assert.ok(listStub.calledOnce);
      assert.strictEqual('FakeTable called back', resp);
    });
  });

  describe('BigQuery client should call underlying methods in the Row Access Policy Client', () => {
    after(() => {
      sinon.restore();
    });
    it('should call listRowAccessPolicies', async () => {
      const rowAccessPolicyRequest = {
        projectId: 'projectId',
        datasetId: 'datasetId',
        tableId: 'tableId', // Ensure all required fields are present
      } as protos.google.cloud.bigquery.v2.IListRowAccessPoliciesRequest;
      const listStub = sinon
        .stub(client.rowaccesspolicyClient, 'listRowAccessPolicies')
        .callsArgWith(2, null, 'FakeRowAccessPoliciesList');
      const resp = client.listRowAccessPolicies(
        rowAccessPolicyRequest,
        {},
        (err, response) => {
          if (err) {
            throw err;
          }
          return response + ' called back';
        }
      );
      assert.ok(listStub.calledOnce);
      assert.strictEqual('FakeRowAccessPoliciesList called back', resp);
    });
  });
});
